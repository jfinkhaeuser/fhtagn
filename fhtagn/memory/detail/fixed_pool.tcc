/**
 * $Id: allocator.h 207 2009-03-17 18:45:11Z unwesen $
 *
 * Copyright (C) 2009 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_MEMORY_DETAIL_FIXED_POOL_TCC
#define FHTAGN_MEMORY_DETAIL_FIXED_POOL_TCC

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <sstream>
#include <stdexcept>

namespace fhtagn {
namespace memory {


fixed_pool::fixed_pool(void * memblock, std::size_t size)
  : m_memblock(memblock)
  , m_size(size)
{
  m_free_list.insert(std::make_pair(m_size, m_memblock));
}



void *
fixed_pool::alloc(std::size_t size)
{
  if (!size) {
    return NULL;
  }

  // Try to find a chunk of the free list that can accomodate the given size.
  free_list_t::iterator chunk_iter = m_free_list.lower_bound(size);
  if (chunk_iter == m_free_list.end()) {
    // Possibly out of memory, but definitely out of chunks large enough.
    return NULL;
  }

  // Remember chunk size and location.
  free_list_t::value_type chunk = *chunk_iter;
  std::cout << "found chunk of size " << chunk.first << " at 0x" << std::hex << (int) chunk.second
    << " in block 0x" << (int) m_memblock << std::dec << " of size " << m_size << std::endl;

  // Erase chunk from free list; it's going to be replaced by a smaller chunk
  // and an entry in the alloc list.
  m_free_list.erase(chunk_iter);

  // Add new free chunk - but only if any amount of memory remains in this cunk
  // after we've used up size bytes.
  std::size_t new_entry_size = chunk.first - size;
  if (new_entry_size) {
    void * new_entry_ptr = static_cast<char *>(chunk.second) + size;
    m_free_list.insert(std::make_pair(new_entry_size, new_entry_ptr));
  }

  // Add used chunk to alloc list.
  m_alloc_list[chunk.second] = size;

  // And finally, return a pointer to the allocated chunk.
  return chunk.second;
}



void *
fixed_pool::realloc(void * ptr, std::size_t new_size)
{
  if (!ptr) {
    return alloc(new_size);
  }

  if (!new_size) {
    return NULL;
  }

  // TODO
  return NULL;
}



void
fixed_pool::free(void * ptr)
{
  if (!ptr) {
    return;
  }

  std::cout << "asked to free 0x" << std::hex << (size_t) ptr << std::dec << std::endl;

  // First check whether the pointer is actually known to us. If it's not,
  // throw a std::logic_error - this is some bug in the caller code.
  alloc_list_t::iterator alloc_iter = m_alloc_list.find(ptr);
  if (alloc_iter == m_alloc_list.end()) {
    std::stringstream s;
    s << "fixed_pool: can't free unknown pointer 0x" << std::hex
      << (std::size_t) ptr << " in pool 0x" << (std::size_t) m_memblock
      << " of size " << m_size;
    throw std::logic_error(s.str());
  }

  // Remember data about the chunk of memory we're about to free, and remove it
  // from the alloc list
  alloc_list_t::value_type chunk = *alloc_iter;
  m_alloc_list.erase(alloc_iter);

  // Now add this chunk as a new entry to the free list.
  m_free_list.insert(std::make_pair(chunk.second, chunk.first));

  // Lastly, defragment the free list.
  defragment_free_list();
}



bool
fixed_pool::in_use() const
{
  return !m_alloc_list.empty();
}



void
fixed_pool::defragment_free_list()
{
  // TODO
}


}} // namespace fhtagn::memory


#endif // guard
