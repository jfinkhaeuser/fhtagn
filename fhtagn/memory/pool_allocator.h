/**
 * $Id$
 *
 * Copyright (C) 2009 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_MEMORY_POOL_ALLOCATOR_H
#define FHTAGN_MEMORY_POOL_ALLOCATOR_H

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <fhtagn/fhtagn.h>

#include <boost/shared_ptr.hpp>

#include <fhtagn/memory/memory_pool.h>

namespace fhtagn {
namespace memory {

/**
 * The pool allocator allocates objects from a preconstructed pool of memory.
 *
 * It may be desirable to use the same pool of memory for multiple types of
 * objects; in order to achieve that, but also retain the possibility of using
 * a different pool for different types, pool_allocators delegate all
 * allocation work to a MemoryPool class that is type-agnostic, but merely
 * handles bytes.
 *
 * During construction of pool_allocation_policy, the MemoryPool from which
 * objects are allocated is determined. If there is already a per-type
 * MemoryPool set, that is used. If not and there is a global MemoryPool set,
 * that is used. If neither is set, you must set the MemoryPool to be used by
 * this instance of pool_allocation_policy via a manual set_memory_pool() call.
 * If none of this happens, your application will crash.
 *
 * Note that once a pool_allocation_policy has constructed objects,
 * set_memory_pool() will fail until they are all destroyed again. Note also
 * that neither of the functions for setting global, per-type or per-instance
 * MemoryPools are thread-safe, and may conflict with any allocations or
 * deallocations made.
 *
 * It is therefore advisable to set the global and per-type MemoryPools (if
 * applicable) before any pool_allocation_policy objects may be created in other
 * threads. For per-instance MemoryPools, best make sure they're set before the
 * container ultimately using them is used.
 *
 * Please be aware that functions for setting memory pools are not thread-safe
 * by design - it's simply not advisable to set memory pools at any point
 * other than program startup.
 *
 * Note also that there is no specific MemoryPool class; MemoryPool is a
 * concept specified in memory_pool.h
 *
 * In order to intialize static members, you must also invoke the
 * FHTAGN_POOL_ALLOCATION_INITIALIZE macro once in your calling code.
 **/
template <
  typename memory_poolT
>
class pool_allocation_policy_base
{
public:
  BOOST_CLASS_REQUIRE(memory_poolT, ::fhtagn::memory::concepts,
      MemoryPoolConcept);

  /**
   * Convenience typedefs
   **/
  typedef memory_poolT                      memory_pool_t;
  typedef boost::shared_ptr<memory_pool_t>  memory_pool_ptr;

  /**
   * Global memory pool. While shared_ptr itself may be thread safe, access to
   * this pointer by pool_allocation_policy<T> may not be.
   **/
  static memory_pool_ptr  global_memory_pool;
};



template <
  typename T,
  typename memory_poolT = ::fhtagn::memory::heap_pool
>
class pool_allocation_policy
  : public pool_allocation_policy_base<memory_poolT>
{
public:
  /**
   * Typedefs aliased from base
   **/
  typedef typename pool_allocation_policy_base<memory_poolT>::memory_pool_t   memory_pool_t;
  typedef typename pool_allocation_policy_base<memory_poolT>::memory_pool_ptr memory_pool_ptr;

  /**
   * Typedefs - aliased by the allocator
   **/
  typedef T                   value_type;
  typedef value_type *        pointer;
  typedef value_type const *  const_pointer;
  typedef value_type &        reference;
  typedef value_type const &  const_reference;
  typedef std::size_t         size_type;
  typedef std::ptrdiff_t      difference_type;


  /**
   * Rebind to allocation policy for different type.
   **/
  template<typename U>
  struct rebind
  {
    typedef pool_allocation_policy<U> other;
  };


  /**
   * Constructors, destructor
   **/
  inline explicit pool_allocation_policy();
  inline ~pool_allocation_policy();

  inline explicit pool_allocation_policy(pool_allocation_policy const &);

  template <typename U>
  inline explicit pool_allocation_policy(pool_allocation_policy<U> const &);

  template <typename U, typename other_poolT>
  inline explicit pool_allocation_policy(pool_allocation_policy<U, other_poolT> const &);


  /**
   * Memory allocation functions.
   **/
  inline pointer allocate(size_type count,
      typename std::allocator<void>::const_pointer = 0);

  inline void deallocate(pointer p, size_type);


  /**
   * Determine size.
   **/
  inline size_type max_size() const;

  /**
   * Per-T memory pool. See global_memory_pool in parent class and class
   * documentation for information on thread-safety.
   **/
  static memory_pool_ptr  per_type_memory_pool;

  /**
   * Get the memory pool currently in use for this instance.
   **/
  inline memory_pool_ptr get_memory_pool() const;

  /**
   * Set the memory pool currently in use for this instance. Will return true
   * on success, else false. If the current memory pool has allocated space to
   * objects, this operation will fail.
   **/
  inline bool set_memory_pool(memory_pool_ptr pool);


private:
  // Sets m_pool to either the type pool or the global pool. If neither is set,
  // a std::logic_error is thrown.
  inline void initialize_pool();

  // The actuall memory pool currently used.
  memory_pool_ptr         m_pool;
};


/**
 * Equality and inequality comparison operators - used to detect if memory
 * allocated from one allocator can be deallocated from the current one.
 * Many variations again, as with the constructors.
 **/
template <
  typename T,
  typename memory_poolT
>
inline bool operator==(
    pool_allocation_policy<T, memory_poolT> const & rhs,
    pool_allocation_policy<T, memory_poolT> const & lhs);



template <
  typename T1,
  typename T2,
  typename memory_poolT
>
inline bool operator==(
    pool_allocation_policy<T1, memory_poolT> const & rhs,
    pool_allocation_policy<T2, memory_poolT> const & lhs);



template <
  typename T1,
  typename memory_poolT1,
  typename T2,
  typename memory_poolT2
>
inline bool operator==(
    pool_allocation_policy<T1, memory_poolT1> const &,
    pool_allocation_policy<T2, memory_poolT2> const &);



template <
  typename T,
  typename memory_poolT,
  typename other_allocatorT
>
inline bool operator==(
    pool_allocation_policy<T, memory_poolT> const &,
    other_allocatorT const &);


}} // namespace fhtagn::memory


#define FHTAGN_POOL_ALLOCATION_INITIALIZE \
  template <typename poolT>                                                     \
  typename fhtagn::memory::pool_allocation_policy_base<poolT>::memory_pool_ptr  \
  fhtagn::memory::pool_allocation_policy_base<poolT>::global_memory_pool;       \
                                                                                \
  template <typename T, typename poolT>                                         \
  typename fhtagn::memory::pool_allocation_policy<T, poolT>::memory_pool_ptr    \
  fhtagn::memory::pool_allocation_policy<T, poolT>::per_type_memory_pool;


#include <fhtagn/memory/detail/pool_allocator.tcc>

#endif // guard
