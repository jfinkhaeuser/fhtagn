/**
 * $Id$
 *
 * Copyright (C) 2007 the authors.
 *
 * Author: Henning Pfeiffer <slashgod@users.sourceforge.net>
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

#include <variant.h>

namespace fhtagn {

boost::shared_ptr<variant> variant::invalid_value;


void
variant::instanciate_invalid_value()
{
    if (!invalid_value) {
        invalid_value = boost::shared_ptr<variant>(new variant(IS_INVALID));
    }
}


variant::variant(variant_state state)
    : m_state(state)
    , m_data()
{
    // only used for null value, so don't instanciate again.
}


variant::variant()
    : m_state(IS_EMPTY)
    , m_data()
{
    instanciate_invalid_value();
}


variant::variant(variant const & other)
    : m_state(other.m_state)
    , m_data(other.m_data)
{
    instanciate_invalid_value();
}


variant &
variant::operator=(variant const & other)
{
    if (this != &other) {
        m_data = other.m_data;
        m_state = other.m_state;
    }
    return *this;
}


variant &
variant::operator[](uint32_t index)
{
    switch (m_state) {
        case IS_INVALID:
            throw std::logic_error("The variant::invalid_value is not a container!");
            break;

        case IS_EMPTY:
            throw std::logic_error("Emtpy variants are not a variant::array_t!");
            break;

        case IS_VALUE:
            if (is<array_t>()) {
                return as<array_t>()[index];
            } else {
                return *invalid_value.get();
            }
            break;

        default:
            assert(0);
    }
}


variant const &
variant::operator[](uint32_t index) const
{
    switch (m_state) {
        case IS_INVALID:
            throw std::logic_error("The variant::invalid_value is not a variant::array_t!");
            break;

        case IS_EMPTY:
            throw std::logic_error("Emtpy variants are not a variant::array_t!");
            break;

        case IS_VALUE:
            if (is<array_t>()) {
                return as<array_t>()[index];
            } else {
                return *invalid_value.get();
            }
            break;

        default:
            assert(0);
    }
}



variant &
variant::operator[](std::string const & key)
{
    switch (m_state) {
        case IS_INVALID:
            throw std::logic_error("The variant::invalid_value is not a variant::map_t!");
            break;

        case IS_EMPTY:
            // we can convert this variant to a map, and map semantics say that
            // non-existing keys get added...
            m_data = map_t();
            m_state = IS_VALUE;
            // fall through

        case IS_VALUE:
            if (is<map_t>()) {
                return as<map_t>()[key];
            } else {
                return *invalid_value.get();
            }
            break;

        default:
            assert(0);
    }
}



variant const &
variant::operator[](std::string const & key) const
{
    switch (m_state) {
        case IS_INVALID:
            throw std::logic_error("The variant::invalid_value is not a variant::map_t!");
            break;

        case IS_EMPTY:
            // technically speaking we could convert this to a map, as in the
            // non-const operator[](string), but since we can't add elements
            // to a const map, there's not much point...
            //
            // fall through
        case IS_VALUE:
            if (is<map_t>()) {
                map_t::const_iterator iter = as<map_t>().find(key);
                if (iter == as<map_t>().end()) {
                  return *invalid_value.get();
                }
                return iter->second;
            } else {
                return *invalid_value.get();
            }

        default:
            assert(0);
    }
}



} // namespace fhtagn
