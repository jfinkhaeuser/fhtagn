/**
 * $Id$
 *
 * Copyright (C) 2007,2008 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


#include <cppunit/Test.h>
#include <cppunit/TestFailure.h>

#include <fhtagn/util/cppunit_output.h>
#include <assert.h>

namespace fhtagn {
namespace util {

namespace {

/** Helper struct to produce padding on an output stream. **/
struct pad
{
    pad(boost::uint32_t pad_length, char pad_char = ' ')
        : m_pad_length(pad_length)
        , m_pad_char(pad_char)
    {
    }

    virtual ~pad()
    {
    }

    virtual void output(std::ostream & os) const
    {
        for (boost::uint32_t i = 0 ; i < m_pad_length ; ++i) {
            os << m_pad_char;
        }
    }

    friend std::ostream & operator<<(std::ostream & os, pad const & p)
    {
        p.output(os);
        return os;
    }

    boost::uint32_t m_pad_length;
    char            m_pad_char;
};


/** Helper struct for indenting output on an output stream **/
struct indent
    : public pad
{
    indent(boost::uint32_t indent_level, boost::uint32_t pad_size)
        : pad(indent_level * pad_size)
    {
    }
};

/** Simplify use of the indent struct */
#define INDENT indent((m_results.size() - 1), m_indent_by)


/** Helper struct for drawing a line on an output stream **/
struct line
    : public indent
{
    line(boost::uint32_t indent_level, boost::uint32_t pad_size, char line_char,
            boost::uint32_t max_line)
        : indent(indent_level, pad_size)
    {
        m_pad_length = max_line - m_pad_length;
        m_pad_char = line_char;
    }
};

/** Simplify use of the line struct */
#define LINE(line_char) line((m_results.size() - 1), m_indent_by, line_char, \
        m_max_line)

} // anonymous namespace


/*****************************************************************************
 * VerboseOutput implementation
 **/

VerboseOutput::VerboseOutput(std::ostream & os,
        boost::uint32_t indent_by /* = 2 */, boost::uint32_t max_line /* = 79 */)
    : m_results()
    , m_status(OK)
    , m_os(os)
    , m_indent_by(indent_by)
    , m_max_line(max_line)
{
    results tmp = { 0, 0, 0 };
    m_results.push(tmp);
}



// Called when just before a TestCase is run.
void
VerboseOutput::startTest(CppUnit::Test * test)
{
    std::string label = "Running `" + test->getName() + "'";
    boost::uint32_t pad_size = m_max_line - label.size() - INDENT.m_pad_length - 12;
    if (pad_size > m_max_line) {
        pad_size = 1;
    }
    m_os << INDENT << label << "..." << pad(pad_size);
}


// Called when a failure occurs while running a test.
void
VerboseOutput::addFailure(CppUnit::TestFailure const & failure)
{
    m_status = (failure.isError() ? ERROR : FAILURE);
}


// Called just after a TestCase was run (even if a failure occured).
void
VerboseOutput::endTest(CppUnit::Test * test)
{
    switch (m_status) {
        case OK:
            m_os << "OK" << std::endl;
            ++(m_results.top().successes);
            break;
        case FAILURE:
            m_os << "FAILURE" << std::endl;
            ++(m_results.top().failures);
            break;
        case ERROR:
            m_os << "ERROR" << std::endl;
            ++(m_results.top().errors);
            break;
        default:
            assert(0);
    }
    m_status = OK;
}


// Called by a TestComposite just before running its child tests.
void
VerboseOutput::startSuite(CppUnit::Test * suite)
{
    m_os << INDENT << LINE('=') << std::endl;
    m_os << indent(m_results.size(), m_indent_by) << "Starting test suite `"
        << suite->getName() << "' with " << suite->getChildTestCount()
        << " children" << std::endl;
    m_os << INDENT << LINE('-') << std::endl;

    results tmp = { 0, 0, 0 };
    m_results.push(tmp);
}

// Called by a TestComposite after running its child tests.
void
VerboseOutput::endSuite(CppUnit::Test * suite)
{
    results suite_results = m_results.top();
    m_results.pop();

    m_os << INDENT << LINE('-') << std::endl;
    m_os << indent(m_results.size(), m_indent_by) << "Suite `" << suite->getName()
              << "' - Total: " << (suite_results.successes + suite_results.failures + suite_results.errors)
              << "   Success: " << suite_results.successes
              << "   Failure: " << suite_results.failures
              << "   Error: " << suite_results.errors << std::endl << std::endl;

    m_results.top().successes += suite_results.successes;
    m_results.top().failures += suite_results.failures;
    m_results.top().errors += suite_results.errors;
}


// Called by a TestRunner before running the test.
void
VerboseOutput::startTestRun(CppUnit::Test * test,
        CppUnit::TestResult * eventManager)
{
    m_os << std::endl;
}


// Called by a TestRunner after running the test.
void
VerboseOutput::endTestRun(CppUnit::Test * test,
        CppUnit::TestResult * eventManager)
{
    m_os << LINE('=') << std::endl;
    if (m_results.top().errors || m_results.top().failures) {
        m_os << INDENT << "Details of errors and failures follow:"
            << std::endl << std::endl;
    }
}


/*****************************************************************************
 * HTMLOutput implementation
 **/


HTMLOutput::HTMLOutput(std::ostream & os)
    : m_results()
    , m_status(OK)
    , m_os(os)
{
    results tmp = { 0, 0, 0 };
    m_results.push(tmp);
}



// Called when just before a TestCase is run.
void
HTMLOutput::startTest(CppUnit::Test * test)
{
    // FIXME div around name?
    m_os << "<table class=\"test-run\"><tr class=\"test-run\">" << std::endl;
    m_os << "<td class=\"test-label\">Running " << test->getName() << "...</td>" << std::endl;
    m_os << "<td class=\"test-output\"><pre class=\"test-output\">";
}


// Called when a failure occurs while running a test.
void
HTMLOutput::addFailure(CppUnit::TestFailure const & failure)
{
    m_status = (failure.isError() ? ERROR : FAILURE);
}


// Called just after a TestCase was run (even if a failure occured).
void
HTMLOutput::endTest(CppUnit::Test * test)
{
    // close test output
    m_os << "</pre></td>" << std::endl;

    switch (m_status) {
        case OK:
            m_os << "<td class=\"test-success\">OK</td>" << std::endl;
            ++(m_results.top().successes);
            break;
        case FAILURE:
            m_os << "<td class=\"test-failure\">FAILURE</td>" << std::endl;
            ++(m_results.top().failures);
            break;
        case ERROR:
            m_os << "<td class=\"test-error\">ERROR</td>" << std::endl;
            ++(m_results.top().errors);
            break;
        default:
            assert(0);
    }
    m_os << "</tr></table>" << std::endl;

    m_status = OK;
}


// Called by a TestComposite just before running its child tests.
void
HTMLOutput::startSuite(CppUnit::Test * suite)
{
    m_os << "<table class=\"suite\">" << std::endl;
    m_os << "<tr class=\"suite-header\">" << std::endl;
    m_os << "<th class=\"suite-header\">" << std::endl;
    m_os << "Starting test suite <a class=\"suite-title\" href=\"#\">"
        << suite->getName() << "</a> with " << suite->getChildTestCount()
        << " children" << std::endl
        << "</th>" << std::endl
        << "</tr>" << std::endl;

    m_os << "<tr class=\"suite-content\">" << std::endl;

    results tmp = { 0, 0, 0 };
    m_results.push(tmp);
}

// Called by a TestComposite after running its child tests.
void
HTMLOutput::endSuite(CppUnit::Test * suite)
{
    results suite_results = m_results.top();
    m_results.pop();

    m_os << "</tr>" << std::endl;

    m_os << "<tr class=\"suite-summary\">" << std::endl
         << "<td class=\"suite-summary\"><table class=\"suite-summary\"><tr class=\"suite-summary-inner\">" << std::endl;
    m_os << "<td class=\"suite-summary-label\">Suite <a class=\"suite-title\" href=\"#\">" << suite->getName()
         << "</a></td>" << std::endl
         << "<td class=\"suite-summary-total-label\">Total:</td>" << std::endl
         << "<td class=\"suite-summary-total\">" << (suite_results.successes + suite_results.failures + suite_results.errors) << "</td>" << std::endl
         << "<td class=\"suite-summary-success-label\">Success:</td>" << std::endl
         << "<td class=\"suite-summary-success\">" << suite_results.successes << "</td>" << std::endl
         << "<td class=\"suite-summary-failure-label\">Failure:</td>" << std::endl
         << "<td class=\"suite-summary-failure\">" << suite_results.failures << "</td>" << std::endl
         << "<td class=\"suite-summary-error-label\">Error:</td>" << std::endl
         << "<td class=\"suite-summary-error\">" << suite_results.errors << "</td>" << std::endl
         ;
    m_os << "</tr></table></td>" << std::endl;
    m_os << "</tr>" << std::endl;

    m_results.top().successes += suite_results.successes;
    m_results.top().failures += suite_results.failures;
    m_results.top().errors += suite_results.errors;
}


// Called by a TestRunner before running the test.
void
HTMLOutput::startTestRun(CppUnit::Test * test,
        CppUnit::TestResult * eventManager)
{
}


// Called by a TestRunner after running the test.
void
HTMLOutput::endTestRun(CppUnit::Test * test,
        CppUnit::TestResult * eventManager)
{
    m_os << "Details of errors and failures follow:" << std::endl;
}



}} // namespace fhtagn::util
