/**
 * $Id$
 *
 * Copyright (C) 2008 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

#include <boost/bind.hpp>
#include <boost/thread/xtime.hpp>

#include <fhtagn/threads/tasklet.h>


namespace fhtagn {
namespace threads {


tasklet::tasklet(tasklet::func_type::slot_type slot)
    : m_done(false)
    , m_stopped(false)
    , m_thread(0)
{
    m_func.connect(slot);
}


tasklet::~tasklet()
{
}


bool
tasklet::start()
{
    boost::mutex::scoped_lock lock(m_mutex);
    if (m_thread) {
        return false;
    }
    m_done = false;
    m_stopped = false;
    m_thread = new boost::thread(boost::bind(&tasklet::thread_runner,
                boost::ref(this)));
    return true;
}


bool
tasklet::stop()
{
    boost::mutex::scoped_lock lock(m_mutex);
    if (!m_thread) {
        return false;
    }
    m_stopped = true;
    lock.unlock();

    m_finish.notify_all();
    return true;
}


bool
tasklet::wait()
{
    boost::mutex::scoped_lock lock(m_mutex);

    if (!m_thread) {
        return false;
    }

    while (!m_done) {
        m_finish.wait(lock);
    }

    m_thread->join();
    delete m_thread;
    m_thread = NULL;
    return true;
}


bool
tasklet::started() const
{
    boost::mutex::scoped_lock lock(m_mutex);
    return (m_thread);
}


bool
tasklet::finished() const
{
    boost::mutex::scoped_lock lock(m_mutex);
    return ((m_thread) && m_done);
}


bool
tasklet::stopped() const
{
    boost::mutex::scoped_lock lock(m_mutex);
    return ((m_thread) && m_stopped);
}




bool
tasklet::sleep(uint32_t usecs /* = 0 */)
{
    // Prepare xtime to sleep until
    boost::xtime t;
    if (usecs) {
        // Add usecs to current time
        boost::xtime_get(&t, boost::TIME_UTC);
        t.sec += usecs / 1000000;
        t.nsec += (usecs % 1000000) * 1000;
        if (t.nsec >= 1000000000) {
            ++t.sec;
            t.nsec -= 1000000000;
        }
    }

    // Sleep until stopped or time runs out.
    boost::mutex::scoped_lock lock(m_mutex);
    while (!m_stopped) {
        if (usecs) {
            // sleep until timeout
            if (!m_finish.timed_wait(lock, t)) {
                // Timeout! We don't care what the flag says, we have to exit
                // right now.
                break;
            }
        } else {
            // sleep indefinitely
            m_finish.wait(lock);
        }
    }
    return m_stopped;
}


void
tasklet::thread_runner()
{
    try {
        m_func(*this);
    } catch (...) {
        // FIXME
    }

    {
        boost::mutex::scoped_lock lock(m_mutex);
        m_done = true;
    }

    m_finish.notify_all();
}


}} // namespace fhtagn::threads
