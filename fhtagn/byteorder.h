/**
 * $Id$
 *
 * Copyright (C) 2007 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_BYTEORDER_H
#define FHTAGN_BYTEORDER_H

#include <stdint.h>

#include <boost/detail/endian.hpp>

namespace fhtagn {
namespace byte_order {

/**
 * Definition of FHTAGN_BIG_ENDIAN and FHTAGN_LITTLE_ENDIAN enum values.
 **/

enum endian
{
    FHTAGN_UNKNOWN_ENDIAN = -1,
    FHTAGN_BIG_ENDIAN     = 0,
    FHTAGN_LITTLE_ENDIAN  = 1,
};


/**
 * Used to define FHTAGN_BYTE_ORDER, see below.
 **/
namespace detail {

template <int ENDIAN>
struct host_helper {
    enum { value = FHTAGN_UNKNOWN_ENDIAN };
};

template <>
struct host_helper<4321>
{
    enum { value = FHTAGN_BIG_ENDIAN };
};

template <>
struct host_helper<1234>
{
    enum { value = FHTAGN_LITTLE_ENDIAN };
};

} // namespace detail


/**
 * In the end, FHTAGN_BYTE_ORDER does not add anything to BOOST_BYTE_ORDER -
 * except that it's either -1, 0 or 1, i.e. values that are more easily used
 * as array indices (see decision matrix in to_host() below).
 **/
enum { FHTAGN_BYTE_ORDER = detail::host_helper<BOOST_BYTE_ORDER>::value };


/**
 * Swap byte order of various integer sizes.
 **/
inline uint16_t swap(uint16_t const & orig)
{
    return ((orig & 0xff00) >> 8) |
           ((orig & 0x00ff) << 8);
}

inline uint32_t swap(uint32_t const & orig)
{
    return ((orig & 0xff000000UL) >> 24) |
           ((orig & 0x00ff0000UL) >> 8)  |
           ((orig & 0x0000ff00UL) << 8)  |
           ((orig & 0x000000ffUL) << 24);
}

inline uint64_t swap(uint64_t const & orig)
{
    return ((orig & 0xff00000000000000ULL) >> 56) |
           ((orig & 0x00ff000000000000ULL) >> 40) |
           ((orig & 0x0000ff0000000000ULL) >> 24) |
           ((orig & 0x000000ff00000000ULL) >> 8)  |
           ((orig & 0x00000000ff000000ULL) >> 8)  |
           ((orig & 0x0000000000ff0000ULL) >> 24) |
           ((orig & 0x000000000000ff00ULL) << 40) |
           ((orig & 0x00000000000000ffULL) << 56);
}



/**
 * Unspecialized declaration of convert. Specialized versions of convert contain
 * hton() and ntoh() functions, which accept any integer type whatsoever. That
 * makes them easier to use in heavily templated code, where the type of integer
 * is not necessarily known. The definitions above are also platform independent
 * (with the drawback that platform dependent specializations /may/ exist and be
 * faster - though that's fairly unlikely).
 **/
template <int ENDIAN = FHTAGN_BYTE_ORDER>
struct convert
{
};



/**
 * FHTAGN_LITTLE_ENDIAN ntoh()/hton() conversions.
 **/
template <>
struct convert<FHTAGN_LITTLE_ENDIAN>
{
    template <typename intT>
    inline static intT hton(intT const & orig)
    {
        // because network byte order is big endian, we need to swap the
        // endianness of the input integer.
        return swap(orig);
    }

    template <typename intT>
    inline static intT ntoh(intT const & orig)
    {
        // because network byte order is big endian, we need to swap the
        // endianness of the input integer.
        return swap(orig);
    }
};



/**
 * FHTAGN_BIG_ENDIAN ntoh()/hton() conversions.
 **/
template <>
struct convert<FHTAGN_BIG_ENDIAN>
{
    template <typename intT>
    inline static intT hton(intT const & orig)
    {
        // network byte order is already big endian, so no changes required.
        return orig;
    }

    template <typename intT>
    inline static intT ntoh(intT const & orig)
    {
        // network byte order is already big endian, so no changes required.
        return orig;
    }
};


/**
 * Use the to_host() function to convert an integer value from a given endianess
 * to the endianess of the host. The function detects whether endianess swapping
 * needs to be performed or not.
 **/
template <typename intT>
inline intT
to_host(intT const & int_value, endian int_endian)
{
    static bool const decision[2][2] = {
        // int is BE   int is LE
        { false,      true,  }, // host BE
        { true,       false, }, // host LE
    };

    if (decision[FHTAGN_BYTE_ORDER][int_endian]) {
        return swap(int_value);
    }
    return int_value;
}


/**
 * The from_host() function more or less does the same as the to_host() function
 * above, except in reverse - it converts an integer from host byte order to the
 * specified byte order.
 **/
template <typename intT>
inline intT
from_host(intT const & int_value, endian int_endian)
{
    static bool const decision[2][2] = {
        // int is BE   int is LE
        { false,      true,  }, // host BE
        { true,       false, }, // host LE
    };

    if (decision[FHTAGN_BYTE_ORDER][int_endian]) {
        return swap(int_value);
    }
    return int_value;
}

}} // namespace fhtagn::byte_order

#endif // guard
