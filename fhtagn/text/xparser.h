/**
 * $Id$
 *
 * Copyright (C) 2007 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_TEXT_XPARSER_H
#define FHTAGN_TEXT_XPARSER_H

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <boost/spirit/core.hpp>

#include <fhtagn/text/transcoding.h>


namespace fhtagn {
namespace text {


/**
 * Simple predefined boost::spirit parsers matching byte order marks (BOMs) for
 * various character encodings.
 **/
// TODO


/**
 * Forward declaration, see documentation below
 **/
class char_parser_factory;



/**
 * The char_parser is a specialization of the char_parser class template from
 * boost::spirit. It's specialties are that
 *   a) it can only be applied to char sequences (not wchar_t or any other
 *      character type), and
 *   b) that it outputs utf32_char_t.
 *
 * Depending on a runtime switch, it will interpret char sequences as utf8,
 * utf16, or a number of other character encodings, and transcode these to
 * utf32_sequences.
 *
 * Due to the way parser grammars are commonly used with boost::spirit, the
 * char_parser class cannot be instanciated directly. In most grammars, you
 * will find definitions such as, e.g.
 *
 *    my_rule = ch_p('x') | 'y' | 'z';
 *
 * What's not immediately apparent is that you want "myrule" to match an 'x',
 * 'y' or 'z' character, where each of those possible matches are encoded
 * in the same way.
 *
 * To facilitate such a use, char_parser below does not contain the runtime
 * flag which input encoding to expect in it's own class body, but rather
 * references a char_parser_factory instance that's passed to it in it's
 * constructor. The char_parser_factory class contains factory methods for
 * different types of char_parser instances, such that your rule definition
 * becomes
 *
 *    my_rule = my_factory_instance.ch_p('x') | 'y' | 'z'
 *
 * Automatically, 'x', 'y' and 'z' are attempted to be matched in the same
 * character encoding, and the choice of encoding to match is defined via
 * a member of my_factory_instance.
 *
 * FIXME see if the above really works.
 **/
template <
    typename derived_parserT
>
struct char_parser
    : public boost::spirit::parser<derived_parserT>
{
    typedef derived_parserT self_t;

    template <typename ScannerT>
    struct result
    {
        /**
         * Using utf32_char_t here ensures that the return type of parse() below
         * expects a match for utf32_char_t characters.
         **/
        typedef typename boost::spirit::match_result<
            ScannerT, utf32_char_t
        >::type type;
    };

    template <typename ScannerT>
    typename boost::spirit::parser_result<self_t, ScannerT>::type
    parse(ScannerT const & scan) const
    {
        typedef typename boost::spirit::parser_result<self_t, ScannerT>::type result_t;
        typedef typename ScannerT::value_t value_t;
        // TODO assert that value_t == char
        typedef typename ScannerT::iterator_t iterator_t;

        m_factory->decoder.reset();
        iterator_t save(scan.first);

        while (!scan.at_end() && m_factory->decoder.feed_byte(*scan)) {
            ++scan.first;
        }

        if (m_factory->decoder.have_sequence()) {
            utf32_char_t utf32_ch = m_factory->decoder.to_utf32();
            if (!this->derived().test(utf32_ch)) {
                return scan.no_match();
            }
            return scan.create_match(1, utf32_ch, save, scan.first);
        }
#if 0
        // FIXME delegate to decoder

        if (!scan.at_end()) {
            iterator_t save(scan.first);

            value_t ch = *scan;
            utf32_char_t utf32_ch = ch;
            if (!this->derived().test(utf32_ch)) {
                return scan.no_match();
            }
            ++scan.first;
            return scan.create_match(1, utf32_ch, save, scan.first);
        }
#endif
        return scan.no_match();
    }

private:
    friend class char_parser_factory;

    char_parser(char_parser_factory const * factory)
        : m_factory(factory)
    {
    }

    char_parser_factory const * m_factory;
};




/**
 * To use the char_parser template above, simply place a char_parser_factory
 * instance into your grammar class. Then, instead of using boost::spirit's
 * anychar_p or ch_p, use the factory functions below.
 **/
struct char_parser_factory
{
    char_parser_factory(char_encoding_type input_encoding = ISO_8859_1)
        : m_input_encoding(input_encoding)
        , anychar_p(this)
    {
    }


    /**
     * Toggle this switch to force all parsers instanciated via this factory to
     * expect characters in the encoding specified here.
     **/
    char_encoding_type m_input_encoding;


    /**
     * Semantically similar to boost::spirit::anychar_parser, except it produces
     * utf32_char_t output from char sequences in different character encodings.
     **/
    struct anychar_parser
        : public char_parser<anychar_parser>
    {
        typedef anychar_parser self_t;

        bool test(utf32_char_t) const
        {
            return true;
        }

    private:
        friend class char_parser_factory;

        anychar_parser(char_parser_factory const * factory)
            : char_parser<anychar_parser>(factory)
        {
        }
    };


    /**
     * An instance of anychar_parser; much as in the boost::spirit example,
     * you'll want to use anychar_p in your grammar definitions.
     **/
    anychar_parser anychar_p;


    /**
     * Semantically similar to boost::spirit::chlit, except it matches the
     * utf32_char_t passed to it's constructor. See ch_p() below.
     **/
    struct chlit
        : public char_parser<chlit>
    {
        typedef anychar_parser self_t;

        bool test(utf32_char_t ch) const
        {
            return (ch == m_ch);
        }

        utf32_char_t m_ch;

    private:
        friend class char_parser_factory;

        chlit(char_parser_factory const * factory, utf32_char_t ch)
            : char_parser<chlit>(factory)
            , m_ch(ch)
        {
        }
    };


    /**
     * Much like it's boost::spirit counterpart, chlit instances are seldom
     * created directly, but most commonly via a ch_p() factory function. This
     * version of ch_p() has identical semantics, but returns chlit instances
     * that match the passed character in any character encoding.
     **/
    chlit ch_p(utf32_char_t ch)
    {
        return chlit(this, ch);
    }
};



}} // namespace fhtagn::text

#endif // guard
