/**
 * $Id$
 *
 * Copyright (C) 2009 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_ALLOCATORS_POOL_ALLOCATOR_H
#define FHTAGN_ALLOCATORS_POOL_ALLOCATOR_H

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <fhtagn/fhtagn.h>

#include <boost/shared_ptr.hpp>

#include <fhtagn/allocators/memory_pool.h>

namespace fhtagn {
namespace allocators {

/**
 * The pool allocator allocates objects from a preconstructed pool of memory.
 *
 * It may be desirable to use the same pool of memory for multiple types of
 * objects; in order to achieve that, but also retain the possibility of using
 * a different pool for different types, pool_allocators delegate all
 * allocation work to a MemoryPool class that is type-agnostic, but merely
 * handles bytes.
 *
 * There is a global MemoryPool instance, and pool_allocation_policy<T> may
 * either use that global MemoryPool to allocate memory, or use a MemoryPool
 * that is unique for T.
 *
 * Given that MemoryPools may manage either dynamically or statically
 * allocated memory, it's up to the user to set the global and/or per-type
 * MemoryPools that the pool_allocation_policy should use. Calls to set
 * MemoryPools *must* occur before any pool_allocation_policy object is
 * constructed.
 *
 * Note that a pool_allocation_policy<T> will use the global MemoryPool if
 * no type-specific memory pool for type T is set. If no global memory pool is
 * set either, your application will crash.
 * Please be aware that functions for setting memory pools are not thread-safe
 * by design - it's simply not advisable to set memory pools at any point
 * other than program startup.
 *
 * Note also that there is no specific MemoryPool class; MemoryPool is a
 * concept specified in memory_pool.h
 *
 * In order to intialize static members, you must also invoke the
 * FHTAGN_POOL_ALLOCATION_INITIALIZE macro once in your calling code.
 **/
template <
  typename memory_poolT
>
class pool_allocation_policy_base
{
public:
  BOOST_CLASS_REQUIRE(memory_poolT, ::fhtagn::allocators::concepts,
      MemoryPoolConcept);

  /**
   * Convenience typedefs
   **/
  typedef memory_poolT                      memory_pool_t;
  typedef boost::shared_ptr<memory_pool_t>  memory_pool_ptr;

  /**
   * Get the global memory pool currently in use.
   **/
  static inline memory_pool_ptr get_global_memory_pool();

  /**
   * Set the global memory pool currently in use. Will return true on success,
   * else false. If the current memory pool has allocated space to objects,
   * this operation will fail.
   **/
  static inline bool set_global_memory_pool(memory_pool_ptr pool);

protected:
  static memory_pool_ptr  sm_global_pool;
};



template <
  typename T,
  typename memory_poolT = ::fhtagn::allocators::heap_pool
>
class pool_allocation_policy
  : public pool_allocation_policy_base<memory_poolT>
{
public:
  /**
   * Typedefs aliased from base
   **/
  typedef typename pool_allocation_policy_base<memory_poolT>::memory_pool_t   memory_pool_t;
  typedef typename pool_allocation_policy_base<memory_poolT>::memory_pool_ptr memory_pool_ptr;

  /**
   * Typedefs - aliased by the allocator
   **/
  typedef T                   value_type;
  typedef value_type *        pointer;
  typedef value_type const *  const_pointer;
  typedef value_type &        reference;
  typedef value_type const &  const_reference;
  typedef std::size_t         size_type;
  typedef std::ptrdiff_t      difference_type;


  /**
   * Rebind to allocation policy for different type.
   **/
  template<typename U>
  struct rebind
  {
    typedef pool_allocation_policy<U> other;
  };


  /**
   * Constructors, destructor
   **/
  inline explicit pool_allocation_policy();
  inline ~pool_allocation_policy();

  inline explicit pool_allocation_policy(pool_allocation_policy const &);

  template <typename U>
  inline explicit pool_allocation_policy(pool_allocation_policy<U> const &);


  /**
   * Memory allocation functions.
   **/
  inline pointer allocate(size_type count,
      typename std::allocator<void>::const_pointer = 0);

  inline void deallocate(pointer p, size_type);


  /**
   * Determine size.
   **/
  inline size_type max_size() const;



  /**
   * Get the per-T memory pool currently in use.
   **/
  static inline memory_pool_ptr get_memory_pool();

  /**
   * Set the per-T memory pool currently in use. Will return true on success,
   * else false. If the current memory pool has allocated space to objects,
   * this operation will fail.
   **/
  static inline bool set_memory_pool(memory_pool_ptr pool);

private:
  // Sets m_pool to either the type pool or the global pool. If neither is set,
  // a std::logic_error is thrown.
  inline void initialize_pool();

  // per-T memory pool
  static memory_pool_ptr  sm_type_pool;

  // The actuall memory pool currently used.
  memory_pool_ptr         m_pool;
};


/**
 * Equality and inequality comparison operators - used to detect if memory
 * allocated from one allocator can be deallocated from the current one.
 * Many variations again, as with the constructors.
 **/
template <
  typename T1,
  typename T2
>
inline bool operator==(
    pool_allocation_policy<T1> const &,
    pool_allocation_policy<T2> const &);



template <
  typename T,
  typename other_allocatorT
>
inline bool operator==(
    pool_allocation_policy<T> const &, other_allocatorT const &);


}} // namespace fhtagn::allocators


#define FHTAGN_POOL_ALLOCATION_INITIALIZE \
  template <typename poolT>                                                         \
  typename fhtagn::allocators::pool_allocation_policy_base<poolT>::memory_pool_ptr  \
  fhtagn::allocators::pool_allocation_policy_base<poolT>::sm_global_pool;           \
                                                                                    \
  template <typename T, typename poolT>                                             \
  typename fhtagn::allocators::pool_allocation_policy<T, poolT>::memory_pool_ptr    \
  fhtagn::allocators::pool_allocation_policy<T, poolT>::sm_type_pool;


#include <fhtagn/allocators/detail/pool_allocator.tcc>

#endif // guard
