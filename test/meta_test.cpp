/**
 * $Id$
 *
 * Copyright (C) 2009 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

#include <vector>

#include <boost/noncopyable.hpp>

#include <cppunit/extensions/HelperMacros.h>

#include <fhtagn/meta/for.h>

namespace {

static int test_sum = 0;

void
dynamic_for_functor1(int i)
{
  test_sum += i;
}


struct dynamic_for_functor2 : boost::noncopyable
{
  void operator()(int i)
  {
    test_sum += i;
  }
};


template <int CURRENT>
struct inc_twice : public fhtagn::meta::increment<CURRENT, 2>
{
};


template <int I>
struct static_functor
{
  void operator()()
  {
    test_sum += I;
  }


  void operator()(int factor)
  {
    test_sum += I * factor;
  }
};


} // anonymous namespace

class MetaTest
    : public CppUnit::TestFixture
{
public:
    CPPUNIT_TEST_SUITE(MetaTest);

      CPPUNIT_TEST(testDynamicFor);
      CPPUNIT_TEST(testStaticFor);

    CPPUNIT_TEST_SUITE_END();

private:
    void testDynamicFor()
    {
      namespace meta = fhtagn::meta;

      // Test both functors with default increments, i.e. inc_once
      test_sum = 0;
      {
        meta::dynamic_for<0, 10>(&dynamic_for_functor1);
        CPPUNIT_ASSERT_EQUAL(45, test_sum);
      }

      test_sum = 0;
      {
        dynamic_for_functor2 f;
        meta::dynamic_for<0, 10>(f);
        CPPUNIT_ASSERT_EQUAL(45, test_sum);
      }

      // Test both functors with increments by two.
      test_sum = 0;
      {
        meta::dynamic_for<0, 10, inc_twice>(&dynamic_for_functor1);
        CPPUNIT_ASSERT_EQUAL(20, test_sum);
      }

      test_sum = 0;
      {
        dynamic_for_functor2 f;
        meta::dynamic_for<0, 10, inc_twice>(f);
        CPPUNIT_ASSERT_EQUAL(20, test_sum);
      }
    }


    void testStaticFor()
    {
      namespace meta = fhtagn::meta;

      // Test functor with default increments and no aditional parameter
      test_sum = 0;
      {
        meta::static_for<0, 10, static_functor>();
        CPPUNIT_ASSERT_EQUAL(45, test_sum);
      }

      // Test functor with increments by two and no additional parameter
      test_sum = 0;
      {
        meta::static_for<0, 10, inc_twice, static_functor>();
        CPPUNIT_ASSERT_EQUAL(20, test_sum);
      }

      // Test functor with default increments and an addtional parameter
      test_sum = 0;
      {
        meta::static_for<0, 10, static_functor>(3);
        CPPUNIT_ASSERT_EQUAL(45 * 3, test_sum);
      }

      // Test functor with increments by two and an additional parameter
      test_sum = 0;
      {
        meta::static_for<0, 10, inc_twice, static_functor>(3);
        CPPUNIT_ASSERT_EQUAL(20 * 3, test_sum);
      }
    }
};


CPPUNIT_TEST_SUITE_REGISTRATION(MetaTest);
